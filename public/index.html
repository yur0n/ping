<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Live Ping Monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { background:#111; color:white; font-family:sans-serif; }
    #stats { margin:10px 0; font-size:16px; }
    table { color:white; border-collapse: collapse; width: 100%; font-size:14px; }
    td,th { border:1px solid #444; padding:2px 6px; }
    canvas { max-height:250px; margin-bottom:20px; }
  </style>
</head>
<body>
<h1>Live Ping Monitor</h1>

<h2>1.1.1.1 - Last 10 minutes</h2>
<canvas id="chart10min"></canvas>

<h2>1.1.1.1 - Historical Chart</h2>
<canvas id="chartHistory"></canvas>

<h2>192.168.1.1 - Historical Chart</h2>
<canvas id="chartHistory2"></canvas>

<div id="stats">loadingâ€¦</div>

<h2>Gaps - 1.1.1.1</h2>
<table id="gapsTable">
<tr><th>from</th><th>to</th><th>count</th></tr>
</table>

<h2>Gaps - 192.168.1.1</h2>
<table id="gapsTable2">
<tr><th>from</th><th>to</th><th>count</th></tr>
</table>

<script>
const eventSource = new EventSource("/events");

const maxWindowMs = 10*60*1000; // 10 minutes
const targets = {
  "1.1.1.1": {
    last10minData: [], // Live data for 10-minute chart
    aggregatedData: [], // Aggregated data for historical chart
    gaps: [],
    received: 0,
    lost: 0,
    avgRtt: 0
  },
  "192.168.1.1": {
    last10minData: [],
    aggregatedData: [],
    gaps: [],
    received: 0,
    lost: 0,
    avgRtt: 0
  }
};

const ctx10 = document.getElementById("chart10min").getContext("2d");
const ctxHist = document.getElementById("chartHistory").getContext("2d");
const ctxHist2 = document.getElementById("chartHistory2").getContext("2d");

const chart10 = new Chart(ctx10, {
  type: "line",
  data: { 
    labels: [], 
    datasets:[
      {label:"RTT (ms)", data:[], borderColor:"aqua", pointRadius:0},
      {label:"Lost packets", data:[], borderColor:"red", pointRadius:3, pointStyle:"cross", showLine:false, backgroundColor:"rgba(255,0,0,0.3)"}
    ] 
  },
  options: { 
    animation:false, 
    scales:{x:{ticks:{color:"white"}}, y:{ticks:{color:"white"}}},
    plugins: {
      legend: { labels: { color: "white" } }
    }
  }
});

const chartHist = new Chart(ctxHist, {
  type: "line",
  data: { 
    labels: [], 
    datasets:[
      {label:"RTT (ms)", data:[], borderColor:"yellow", pointRadius:0},
      {label:"Lost packets", data:[], borderColor:"red", pointRadius:2, pointStyle:"cross", showLine:false, backgroundColor:"rgba(255,0,0,0.2)"}
    ] 
  },
  options: { 
    animation:false, 
    scales:{x:{ticks:{color:"white"}}, y:{ticks:{color:"white"}}},
    plugins: {
      legend: { labels: { color: "white" } }
    }
  }
});

const chartHist2 = new Chart(ctxHist2, {
  type: "line",
  data: { 
    labels: [], 
    datasets:[
      {label:"RTT (ms)", data:[], borderColor:"orange", pointRadius:0},
      {label:"Lost packets", data:[], borderColor:"red", pointRadius:2, pointStyle:"cross", showLine:false, backgroundColor:"rgba(255,0,0,0.2)"}
    ] 
  },
  options: { 
    animation:false, 
    scales:{x:{ticks:{color:"white"}}, y:{ticks:{color:"white"}}},
    plugins: {
      legend: { labels: { color: "white" } }
    }
  }
});

function updateCharts(targetIp, point) {
  const target = targets[targetIp];
  if (!target) return;

  // Skip null RTT values (lost packets) for charts
  if (point.rtt === null || point.rtt === undefined) return;

  // Only update 10-minute chart with live data (not historical)
  if (targetIp === "1.1.1.1") {
    // Add point to 10-minute data
    target.last10minData.push(point);
    const now = Date.now();
    // Keep only last 10 minutes
    target.last10minData = target.last10minData.filter(p => !p.timestamp || now - p.timestamp <= maxWindowMs);

    // Update 10-minute chart
    const valid10minData = target.last10minData.filter(p => p.rtt !== null && p.rtt !== undefined);
    
    // Collect all seq numbers including gaps in visible range
    const allSeqs10 = new Set();
    valid10minData.forEach(p => allSeqs10.add(p.seq));
    // Add gaps that are in the visible range
    if (valid10minData.length > 0) {
      const minSeq = Math.min(...valid10minData.map(p => p.seq));
      const maxSeq = Math.max(...valid10minData.map(p => p.seq));
      target.gaps.forEach(gap => {
        for (let seq = gap.from; seq <= gap.to; seq++) {
          if (seq >= minSeq && seq <= maxSeq) {
            allSeqs10.add(seq);
          }
        }
      });
    }
    const sortedSeqs10 = Array.from(allSeqs10).sort((a, b) => a - b);
    
    chart10.data.labels = sortedSeqs10;
    // Fill data array - null for gaps, rtt for valid data
    chart10.data.datasets[0].data = sortedSeqs10.map(seq => {
      const point = valid10minData.find(p => p.seq === seq);
      return point ? point.rtt : null;
    });
    
    // Update gaps visualization
    const maxRtt10 = Math.max(...chart10.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
    const gapsData10 = sortedSeqs10.map(seq => {
      // Check if this seq is in a gap
      const isGap = target.gaps.some(gap => seq >= gap.from && seq <= gap.to);
      return isGap ? maxRtt10 * 1.1 : null;
    });
    chart10.data.datasets[1].data = gapsData10;
    chart10.update();
  }
  // Historical charts are updated only from aggregated data on history load
}

eventSource.onmessage = (event)=>{
  const data = JSON.parse(event.data);

  if(data.type==="history"){
    if (data.targets) {
      Object.keys(data.targets).forEach(ip => {
        const targetData = data.targets[ip];
        // Store aggregated data for historical charts
        targets[ip].aggregatedData = targetData.aggregatedData || [];
        // Store recent data for 10-minute chart
        targets[ip].last10minData = targetData.recentData || [];
        targets[ip].gaps = targetData.gaps || [];
        targets[ip].received = targetData.received || 0;
        targets[ip].lost = targetData.lost || 0;
        targets[ip].avgRtt = targetData.avgRtt || 0;
      });
      
      // Update charts once after loading all history data
      const t1 = targets["1.1.1.1"];
      const t2 = targets["192.168.1.1"];
      
      // Update 1.1.1.1 historical chart - only aggregated data
      const validT1AggData = t1.aggregatedData.filter(p => p.rtt !== null && p.rtt !== undefined);
      
      // Collect all seq numbers including gaps
      const allSeqs = new Set();
      validT1AggData.forEach(p => allSeqs.add(p.seq));
      t1.gaps.forEach(gap => {
        for (let seq = gap.from; seq <= gap.to; seq++) {
          allSeqs.add(seq);
        }
      });
      const sortedSeqs = Array.from(allSeqs).sort((a, b) => a - b);
      
      chartHist.data.labels = sortedSeqs;
      // Fill data array - null for gaps, rtt for valid data
      chartHist.data.datasets[0].data = sortedSeqs.map(seq => {
        const point = validT1AggData.find(p => p.seq === seq);
        return point ? point.rtt : null;
      });
      
      // Add gaps visualization
      const maxRtt1 = Math.max(...chartHist.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsData1 = sortedSeqs.map(seq => {
        // Check if this seq is in a gap
        const isGap = t1.gaps.some(gap => seq >= gap.from && seq <= gap.to);
        return isGap ? maxRtt1 * 1.1 : null;
      });
      chartHist.data.datasets[1].data = gapsData1;
      chartHist.update('none');
      
      // Update 192.168.1.1 historical chart - only aggregated data
      const validT2AggData = t2.aggregatedData.filter(p => p.rtt !== null && p.rtt !== undefined);
      
      // Collect all seq numbers including gaps
      const allSeqs2 = new Set();
      validT2AggData.forEach(p => allSeqs2.add(p.seq));
      t2.gaps.forEach(gap => {
        for (let seq = gap.from; seq <= gap.to; seq++) {
          allSeqs2.add(seq);
        }
      });
      const sortedSeqs2 = Array.from(allSeqs2).sort((a, b) => a - b);
      
      chartHist2.data.labels = sortedSeqs2;
      // Fill data array - null for gaps, rtt for valid data
      chartHist2.data.datasets[0].data = sortedSeqs2.map(seq => {
        const point = validT2AggData.find(p => p.seq === seq);
        return point ? point.rtt : null;
      });
      
      // Add gaps visualization
      const maxRtt2 = Math.max(...chartHist2.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsData2 = sortedSeqs2.map(seq => {
        // Check if this seq is in a gap
        const isGap = t2.gaps.some(gap => seq >= gap.from && seq <= gap.to);
        return isGap ? maxRtt2 * 1.1 : null;
      });
      chartHist2.data.datasets[1].data = gapsData2;
      chartHist2.update('none');
      
      // Update 10-minute window for 1.1.1.1 - only recent live data
      const valid10minData = t1.last10minData.filter(p => p.rtt !== null && p.rtt !== undefined);
      
      // Collect all seq numbers including gaps in visible range
      const allSeqs10 = new Set();
      valid10minData.forEach(p => allSeqs10.add(p.seq));
      // Add gaps that are in the visible range
      if (valid10minData.length > 0) {
        const minSeq = Math.min(...valid10minData.map(p => p.seq));
        const maxSeq = Math.max(...valid10minData.map(p => p.seq));
        t1.gaps.forEach(gap => {
          for (let seq = gap.from; seq <= gap.to; seq++) {
            if (seq >= minSeq && seq <= maxSeq) {
              allSeqs10.add(seq);
            }
          }
        });
      }
      const sortedSeqs10 = Array.from(allSeqs10).sort((a, b) => a - b);
      
      chart10.data.labels = sortedSeqs10;
      // Fill data array - null for gaps, rtt for valid data
      chart10.data.datasets[0].data = sortedSeqs10.map(seq => {
        const point = valid10minData.find(p => p.seq === seq);
        return point ? point.rtt : null;
      });
      
      // Add gaps visualization
      const maxRtt10 = Math.max(...chart10.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsData10 = sortedSeqs10.map(seq => {
        // Check if this seq is in a gap
        const isGap = t1.gaps.some(gap => seq >= gap.from && seq <= gap.to);
        return isGap ? maxRtt10 * 1.1 : null;
      });
      chart10.data.datasets[1].data = gapsData10;
      chart10.update('none');
    }
    updateTable();
    updateStats();
    return;
  }

  if(data.point && data.target) {
    updateCharts(data.target, data.point);
    targets[data.target].gaps = data.gaps || [];
    targets[data.target].received = data.received || 0;
    targets[data.target].lost = data.lost || 0;
    if (data.avgRtt !== undefined) {
      targets[data.target].avgRtt = data.avgRtt;
    }
    // Update gaps visualization on historical charts
    updateGapsOnCharts(data.target);
    updateTable();
    updateStats();
  }
};

eventSource.onerror = (err) => {
  console.error("SSE error:", err);
  // EventSource will automatically try to reconnect
};

function updateStats(){
  const t1 = targets["1.1.1.1"];
  const t2 = targets["192.168.1.1"];
  document.getElementById("stats").innerHTML =
    `<strong>1.1.1.1:</strong> Received: ${t1.received} | Lost: ${t1.lost} | Loss: ${(t1.lost/(t1.received+t1.lost)*100).toFixed(2)}% | Avg RTT: ${t1.avgRtt} ms<br>` +
    `<strong>192.168.1.1:</strong> Received: ${t2.received} | Lost: ${t2.lost} | Loss: ${(t2.lost/(t2.received+t2.lost)*100).toFixed(2)}% | Avg RTT: ${t2.avgRtt} ms`;
}

function updateGapsOnCharts(targetIp) {
  const target = targets[targetIp];
  if (!target) return;
  
  if (targetIp === "1.1.1.1") {
    // Update historical chart gaps (only aggregated data)
    if (chartHist.data.labels.length > 0) {
      const maxRtt = Math.max(...chartHist.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsDataHist = chartHist.data.labels.map(seq => {
        // Check if this seq is in a gap
        const isGap = target.gaps.some(gap => seq >= gap.from && seq <= gap.to);
        return isGap ? maxRtt * 1.1 : null;
      });
      chartHist.data.datasets[1].data = gapsDataHist;
      chartHist.update('none');
    }
    
    // Update 10-minute chart gaps (only live data)
    if (chart10.data.labels.length > 0) {
      const maxRtt10 = Math.max(...chart10.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsData10 = chart10.data.labels.map(seq => {
        // Check if this seq is in a gap
        const isGap = target.gaps.some(gap => seq >= gap.from && seq <= gap.to);
        return isGap ? maxRtt10 * 1.1 : null;
      });
      chart10.data.datasets[1].data = gapsData10;
      chart10.update('none');
    }
  } else if (targetIp === "192.168.1.1") {
    // Update historical chart gaps (only aggregated data)
    if (chartHist2.data.labels.length > 0) {
      const maxRtt = Math.max(...chartHist2.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsDataHist = chartHist2.data.labels.map(seq => {
        // Check if this seq is in a gap
        const isGap = target.gaps.some(gap => seq >= gap.from && seq <= gap.to);
        return isGap ? maxRtt * 1.1 : null;
      });
      chartHist2.data.datasets[1].data = gapsDataHist;
      chartHist2.update('none');
    }
  }
}

function updateTable(){
  const gapsTable = document.getElementById("gapsTable");
  gapsTable.innerHTML="<tr><th>from</th><th>to</th><th>count</th></tr>";
  targets["1.1.1.1"].gaps.forEach(g=>{
    gapsTable.innerHTML+=`<tr><td>${g.from}</td><td>${g.to}</td><td>${g.count}</td></tr>`;
  });
  
  const gapsTable2 = document.getElementById("gapsTable2");
  gapsTable2.innerHTML="<tr><th>from</th><th>to</th><th>count</th></tr>";
  targets["192.168.1.1"].gaps.forEach(g=>{
    gapsTable2.innerHTML+=`<tr><td>${g.from}</td><td>${g.to}</td><td>${g.count}</td></tr>`;
  });
}
</script>
</body>
</html>
