<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Live Ping Monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { background:#111; color:white; font-family:sans-serif; }
    #stats { margin:10px 0; font-size:16px; }
    table { color:white; border-collapse: collapse; width: 100%; font-size:14px; }
    td,th { border:1px solid #444; padding:2px 6px; }
    canvas { max-height:250px; margin-bottom:20px; }
  </style>
</head>
<body>
<h1>Live Ping Monitor</h1>

<h2>1.1.1.1 - Last 10 minutes</h2>
<canvas id="chart10min"></canvas>

<h2>1.1.1.1 - Historical Chart</h2>
<canvas id="chartHistory"></canvas>

<h2>192.168.1.1 - Historical Chart</h2>
<canvas id="chartHistory2"></canvas>

<div id="stats">loadingâ€¦</div>

<h2>Gaps - 1.1.1.1</h2>
<table id="gapsTable">
<tr><th>from</th><th>to</th><th>count</th><th>time</th></tr>
</table>

<h2>Gaps - 192.168.1.1</h2>
<table id="gapsTable2">
<tr><th>from</th><th>to</th><th>count</th><th>time</th></tr>
</table>

<script>
const eventSource = new EventSource("/events");

const maxWindowMs = 10*60*1000; // 10 minutes

// Format timestamp to time string
function formatTime(timestamp) {
  if (!timestamp) return "N/A";
  const date = new Date(timestamp);
  return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
}

// Format timestamp for chart labels (shorter format)
function formatTimeShort(timestamp) {
  if (!timestamp) return "";
  const date = new Date(timestamp);
  return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
}

// Find approximate timestamp for a seq number
function findTimestampForSeq(targetIp, seq) {
  const target = targets[targetIp];
  if (!target) return null;
  
  // First check recentData
  const recentPoint = target.last10minData.find(p => p.seq === seq);
  if (recentPoint && recentPoint.timestamp) return recentPoint.timestamp;
  
  // Then check aggregatedData
  const aggPoint = target.aggregatedData.find(p => p.seq === seq);
  if (aggPoint && aggPoint.timestamp) return aggPoint.timestamp;
  
  // If not found, estimate based on nearest points
  const allData = [...target.aggregatedData, ...target.last10minData].filter(p => p.timestamp);
  if (allData.length === 0) return null;
  
  // Find closest point by seq
  let closest = allData[0];
  let minDiff = Math.abs(closest.seq - seq);
  for (const point of allData) {
    const diff = Math.abs(point.seq - seq);
    if (diff < minDiff) {
      minDiff = diff;
      closest = point;
    }
  }
  
  // Estimate timestamp: assume 1 second per ping
  const seqDiff = seq - closest.seq;
  return closest.timestamp + (seqDiff * 1000);
}

const targets = {
  "1.1.1.1": {
    last10minData: [], // Live data for 10-minute chart
    aggregatedData: [], // Aggregated data for historical chart
    gaps: [],
    received: 0,
    lost: 0,
    avgRtt: 0
  },
  "192.168.1.1": {
    last10minData: [],
    aggregatedData: [],
    gaps: [],
    received: 0,
    lost: 0,
    avgRtt: 0
  }
};

const ctx10 = document.getElementById("chart10min").getContext("2d");
const ctxHist = document.getElementById("chartHistory").getContext("2d");
const ctxHist2 = document.getElementById("chartHistory2").getContext("2d");

const chart10 = new Chart(ctx10, {
  type: "line",
  data: { 
    labels: [], 
    datasets:[
      {label:"RTT (ms)", data:[], borderColor:"aqua", pointRadius:0},
      {label:"Lost packets", data:[], borderColor:"red", pointRadius:3, pointStyle:"cross", showLine:false, backgroundColor:"rgba(255,0,0,0.3)"}
    ] 
  },
  options: { 
    animation:false, 
    scales:{x:{ticks:{color:"white"}}, y:{ticks:{color:"white"}}},
    plugins: {
      legend: { labels: { color: "white" } }
    }
  }
});

const chartHist = new Chart(ctxHist, {
  type: "line",
  data: { 
    labels: [], 
    datasets:[
      {label:"RTT (ms)", data:[], borderColor:"yellow", pointRadius:0},
      {label:"Lost packets", data:[], borderColor:"red", pointRadius:2, pointStyle:"cross", showLine:false, backgroundColor:"rgba(255,0,0,0.2)"}
    ] 
  },
  options: { 
    animation:false, 
    scales:{x:{ticks:{color:"white"}}, y:{ticks:{color:"white"}}},
    plugins: {
      legend: { labels: { color: "white" } }
    }
  }
});

const chartHist2 = new Chart(ctxHist2, {
  type: "line",
  data: { 
    labels: [], 
    datasets:[
      {label:"RTT (ms)", data:[], borderColor:"orange", pointRadius:0},
      {label:"Lost packets", data:[], borderColor:"red", pointRadius:2, pointStyle:"cross", showLine:false, backgroundColor:"rgba(255,0,0,0.2)"}
    ] 
  },
  options: { 
    animation:false, 
    scales:{x:{ticks:{color:"white"}}, y:{ticks:{color:"white"}}},
    plugins: {
      legend: { labels: { color: "white" } }
    }
  }
});

function updateCharts(targetIp, point) {
  const target = targets[targetIp];
  if (!target) return;

  // Skip null RTT values (lost packets) for charts
  if (point.rtt === null || point.rtt === undefined) return;

  // Only update 10-minute chart with live data (not historical)
  if (targetIp === "1.1.1.1") {
    // Add point to 10-minute data
    target.last10minData.push(point);
    const now = Date.now();
    // Keep only last 10 minutes
    target.last10minData = target.last10minData.filter(p => !p.timestamp || now - p.timestamp <= maxWindowMs);

    // Update 10-minute chart
    const valid10minData = target.last10minData.filter(p => p.rtt !== null && p.rtt !== undefined);
    
    // Collect all seq numbers including gaps in visible range
    const allSeqs10 = new Set();
    valid10minData.forEach(p => allSeqs10.add(p.seq));
    // Add gaps that are in the visible range
    if (valid10minData.length > 0) {
      const minSeq = Math.min(...valid10minData.map(p => p.seq));
      const maxSeq = Math.max(...valid10minData.map(p => p.seq));
      target.gaps.forEach(gap => {
        for (let seq = gap.from; seq <= gap.to; seq++) {
          if (seq >= minSeq && seq <= maxSeq) {
            allSeqs10.add(seq);
          }
        }
      });
    }
    const sortedSeqs10 = Array.from(allSeqs10).sort((a, b) => a - b);
    
    // Create labels with time
    chart10.data.labels = sortedSeqs10.map(seq => {
      const point = valid10minData.find(p => p.seq === seq);
      if (point && point.timestamp) {
        return formatTimeShort(point.timestamp);
      }
      // For gaps, estimate time
      const timestamp = findTimestampForSeq(targetIp, seq);
      return timestamp ? formatTimeShort(timestamp) : seq.toString();
    });
    // Fill data array - null for gaps, rtt for valid data
    chart10.data.datasets[0].data = sortedSeqs10.map(seq => {
      const point = valid10minData.find(p => p.seq === seq);
      return point ? point.rtt : null;
    });
    
    // Update gaps visualization
    const maxRtt10 = Math.max(...chart10.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
    const gapsData10 = sortedSeqs10.map(seq => {
      // Check if this seq is in a gap
      const isGap = target.gaps.some(gap => seq >= gap.from && seq <= gap.to);
      return isGap ? maxRtt10 * 1.1 : null;
    });
    chart10.data.datasets[1].data = gapsData10;
    chart10.update();
  }
  // Historical charts are updated only from aggregated data on history load
}

eventSource.onmessage = (event)=>{
  const data = JSON.parse(event.data);

  if(data.type==="history"){
    if (data.targets) {
      Object.keys(data.targets).forEach(ip => {
        const targetData = data.targets[ip];
        // Store aggregated data for historical charts
        targets[ip].aggregatedData = targetData.aggregatedData || [];
        // Store recent data for 10-minute chart
        targets[ip].last10minData = targetData.recentData || [];
        targets[ip].gaps = targetData.gaps || [];
        targets[ip].received = targetData.received || 0;
        targets[ip].lost = targetData.lost || 0;
        targets[ip].avgRtt = targetData.avgRtt || 0;
      });
      
      // Update charts once after loading all history data
      const t1 = targets["1.1.1.1"];
      const t2 = targets["192.168.1.1"];
      
      // Update 1.1.1.1 historical chart - only aggregated data
      const validT1AggData = t1.aggregatedData.filter(p => p.rtt !== null && p.rtt !== undefined);
      
      // For historical chart, don't add gaps to labels to avoid large empty spaces
      // Only show gaps that are close to existing data points
      chartHist.data.labels = validT1AggData.map(p => {
        if (p.timestamp) {
          return formatTimeShort(p.timestamp);
        }
        return p.seq.toString();
      });
      chartHist.data.datasets[0].data = validT1AggData.map(p => p.rtt);
      
      // Add gaps visualization - only show gaps near existing data points
      const maxRtt1 = Math.max(...chartHist.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsData1 = new Array(chartHist.data.labels.length).fill(null);
      
      // Find gaps that are close to existing data points (within 10 seq)
      t1.gaps.forEach(gap => {
        for (let seq = gap.from; seq <= gap.to; seq++) {
          // Find closest data point by seq
          let closestIndex = -1;
          let minDiff = Infinity;
          validT1AggData.forEach((p, idx) => {
            const diff = Math.abs(p.seq - seq);
            if (diff <= 10 && diff < minDiff) {
              minDiff = diff;
              closestIndex = idx;
            }
          });
          if (closestIndex !== -1) {
            // Show gap marker at the closest data point position
            gapsData1[closestIndex] = maxRtt1 * 1.1;
          }
        }
      });
      chartHist.data.datasets[1].data = gapsData1;
      chartHist.update('none');
      
      // Update 192.168.1.1 historical chart - only aggregated data
      const validT2AggData = t2.aggregatedData.filter(p => p.rtt !== null && p.rtt !== undefined);
      
      // For historical chart, don't add gaps to labels to avoid large empty spaces
      chartHist2.data.labels = validT2AggData.map(p => {
        if (p.timestamp) {
          return formatTimeShort(p.timestamp);
        }
        return p.seq.toString();
      });
      chartHist2.data.datasets[0].data = validT2AggData.map(p => p.rtt);
      
      // Add gaps visualization - only show gaps near existing data points
      const maxRtt2 = Math.max(...chartHist2.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsData2 = new Array(chartHist2.data.labels.length).fill(null);
      
      // Find gaps that are close to existing data points (within 10 seq)
      t2.gaps.forEach(gap => {
        for (let seq = gap.from; seq <= gap.to; seq++) {
          // Find closest data point by seq
          let closestIndex = -1;
          let minDiff = Infinity;
          validT2AggData.forEach((p, idx) => {
            const diff = Math.abs(p.seq - seq);
            if (diff <= 10 && diff < minDiff) {
              minDiff = diff;
              closestIndex = idx;
            }
          });
          if (closestIndex !== -1) {
            // Show gap marker at the closest data point position
            gapsData2[closestIndex] = maxRtt2 * 1.1;
          }
        }
      });
      chartHist2.data.datasets[1].data = gapsData2;
      chartHist2.update('none');
      
      // Update 10-minute window for 1.1.1.1 - only recent live data
      const valid10minData = t1.last10minData.filter(p => p.rtt !== null && p.rtt !== undefined);
      
      // Collect all seq numbers including gaps in visible range
      const allSeqs10 = new Set();
      valid10minData.forEach(p => allSeqs10.add(p.seq));
      // Add gaps that are in the visible range
      if (valid10minData.length > 0) {
        const minSeq = Math.min(...valid10minData.map(p => p.seq));
        const maxSeq = Math.max(...valid10minData.map(p => p.seq));
        t1.gaps.forEach(gap => {
          for (let seq = gap.from; seq <= gap.to; seq++) {
            if (seq >= minSeq && seq <= maxSeq) {
              allSeqs10.add(seq);
            }
          }
        });
      }
      const sortedSeqs10 = Array.from(allSeqs10).sort((a, b) => a - b);
      
      // Create labels with time
      chart10.data.labels = sortedSeqs10.map(seq => {
        const point = valid10minData.find(p => p.seq === seq);
        if (point && point.timestamp) {
          return formatTimeShort(point.timestamp);
        }
        // For gaps, estimate time
        const timestamp = findTimestampForSeq("1.1.1.1", seq);
        return timestamp ? formatTimeShort(timestamp) : seq.toString();
      });
      // Fill data array - null for gaps, rtt for valid data
      chart10.data.datasets[0].data = sortedSeqs10.map(seq => {
        const point = valid10minData.find(p => p.seq === seq);
        return point ? point.rtt : null;
      });
      
      // Add gaps visualization
      const maxRtt10 = Math.max(...chart10.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsData10 = sortedSeqs10.map(seq => {
        // Check if this seq is in a gap
        const isGap = t1.gaps.some(gap => seq >= gap.from && seq <= gap.to);
        return isGap ? maxRtt10 * 1.1 : null;
      });
      chart10.data.datasets[1].data = gapsData10;
      chart10.update('none');
    }
    updateTable();
    updateStats();
    return;
  }

  if(data.point && data.target) {
    updateCharts(data.target, data.point);
    targets[data.target].gaps = data.gaps || [];
    targets[data.target].received = data.received || 0;
    targets[data.target].lost = data.lost || 0;
    if (data.avgRtt !== undefined) {
      targets[data.target].avgRtt = data.avgRtt;
    }
    // Update gaps visualization on historical charts
    updateGapsOnCharts(data.target);
    updateTable();
    updateStats();
  }
};

eventSource.onerror = (err) => {
  console.error("SSE error:", err);
  // EventSource will automatically try to reconnect
};

function updateStats(){
  const t1 = targets["1.1.1.1"];
  const t2 = targets["192.168.1.1"];
  document.getElementById("stats").innerHTML =
    `<strong>1.1.1.1:</strong> Received: ${t1.received} | Lost: ${t1.lost} | Loss: ${(t1.lost/(t1.received+t1.lost)*100).toFixed(2)}% | Avg RTT: ${t1.avgRtt} ms<br>` +
    `<strong>192.168.1.1:</strong> Received: ${t2.received} | Lost: ${t2.lost} | Loss: ${(t2.lost/(t2.received+t2.lost)*100).toFixed(2)}% | Avg RTT: ${t2.avgRtt} ms`;
}

function updateGapsOnCharts(targetIp) {
  const target = targets[targetIp];
  if (!target) return;
  
  if (targetIp === "1.1.1.1") {
    // Update historical chart gaps - only show gaps near existing data points
    if (chartHist.data.labels.length > 0) {
      const maxRtt = Math.max(...chartHist.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsDataHist = new Array(chartHist.data.labels.length).fill(null);
      
      // Find gaps that are close to existing data points (within 10 seq)
      // Need to get valid aggregated data to find closest points by seq
      const validAggData = target.aggregatedData.filter(p => p.rtt !== null && p.rtt !== undefined);
      target.gaps.forEach(gap => {
        for (let seq = gap.from; seq <= gap.to; seq++) {
          // Find closest data point by seq
          let closestIndex = -1;
          let minDiff = Infinity;
          validAggData.forEach((p, idx) => {
            const diff = Math.abs(p.seq - seq);
            if (diff <= 10 && diff < minDiff) {
              minDiff = diff;
              closestIndex = idx;
            }
          });
          if (closestIndex !== -1) {
            gapsDataHist[closestIndex] = maxRtt * 1.1;
          }
        }
      });
      chartHist.data.datasets[1].data = gapsDataHist;
      chartHist.update('none');
    }
    
    // Update 10-minute chart gaps (only live data) - show all gaps in range
    if (chart10.data.labels.length > 0) {
      const maxRtt10 = Math.max(...chart10.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const valid10minData = target.last10minData.filter(p => p.rtt !== null && p.rtt !== undefined);
      
      // Collect all seq numbers including gaps in visible range
      const allSeqs10 = new Set();
      valid10minData.forEach(p => allSeqs10.add(p.seq));
      if (valid10minData.length > 0) {
        const minSeq = Math.min(...valid10minData.map(p => p.seq));
        const maxSeq = Math.max(...valid10minData.map(p => p.seq));
        target.gaps.forEach(gap => {
          for (let seq = gap.from; seq <= gap.to; seq++) {
            if (seq >= minSeq && seq <= maxSeq) {
              allSeqs10.add(seq);
            }
          }
        });
      }
      const sortedSeqs10 = Array.from(allSeqs10).sort((a, b) => a - b);
      
      const gapsData10 = sortedSeqs10.map(seq => {
        // Check if this seq is in a gap
        const isGap = target.gaps.some(gap => seq >= gap.from && seq <= gap.to);
        return isGap ? maxRtt10 * 1.1 : null;
      });
      chart10.data.datasets[1].data = gapsData10;
      chart10.update('none');
    }
  } else if (targetIp === "192.168.1.1") {
    // Update historical chart gaps - only show gaps near existing data points
    if (chartHist2.data.labels.length > 0) {
      const maxRtt = Math.max(...chartHist2.data.datasets[0].data.filter(v => v !== null && v !== undefined), 0) || 100;
      const gapsDataHist = new Array(chartHist2.data.labels.length).fill(null);
      
      // Find gaps that are close to existing data points (within 10 seq)
      // Need to get valid aggregated data to find closest points by seq
      const validAggData2 = target.aggregatedData.filter(p => p.rtt !== null && p.rtt !== undefined);
      target.gaps.forEach(gap => {
        for (let seq = gap.from; seq <= gap.to; seq++) {
          // Find closest data point by seq
          let closestIndex = -1;
          let minDiff = Infinity;
          validAggData2.forEach((p, idx) => {
            const diff = Math.abs(p.seq - seq);
            if (diff <= 10 && diff < minDiff) {
              minDiff = diff;
              closestIndex = idx;
            }
          });
          if (closestIndex !== -1) {
            gapsDataHist[closestIndex] = maxRtt * 1.1;
          }
        }
      });
      chartHist2.data.datasets[1].data = gapsDataHist;
      chartHist2.update('none');
    }
  }
}

function updateTable(){
  const gapsTable = document.getElementById("gapsTable");
  gapsTable.innerHTML="<tr><th>from</th><th>to</th><th>count</th><th>time</th></tr>";
  targets["1.1.1.1"].gaps.forEach(g=>{
    const timeFrom = findTimestampForSeq("1.1.1.1", g.from);
    const timeTo = findTimestampForSeq("1.1.1.1", g.to);
    const timeStr = timeFrom && timeTo 
      ? `${formatTime(timeFrom)} - ${formatTime(timeTo)}`
      : "N/A";
    gapsTable.innerHTML+=`<tr><td>${g.from}</td><td>${g.to}</td><td>${g.count}</td><td>${timeStr}</td></tr>`;
  });
  
  const gapsTable2 = document.getElementById("gapsTable2");
  gapsTable2.innerHTML="<tr><th>from</th><th>to</th><th>count</th><th>time</th></tr>";
  targets["192.168.1.1"].gaps.forEach(g=>{
    const timeFrom = findTimestampForSeq("192.168.1.1", g.from);
    const timeTo = findTimestampForSeq("192.168.1.1", g.to);
    const timeStr = timeFrom && timeTo 
      ? `${formatTime(timeFrom)} - ${formatTime(timeTo)}`
      : "N/A";
    gapsTable2.innerHTML+=`<tr><td>${g.from}</td><td>${g.to}</td><td>${g.count}</td><td>${timeStr}</td></tr>`;
  });
}
</script>
</body>
</html>
